"""
Author:         Nate Koike & Zhaosen Guo
Date:           2021/2/22
Description:    Implement an agent to clean a 2d environment based on various
                search algorithms.
    *****
    Run with the following command formats:
    python3 project1.py [env_num:int] [search_alg:str] [search_type:str] [max_time:unsigned_int]
    python project1.py [env_num:int] [search_alg:str] [search_type:str] [max_time:unsigned_int]

    e.g.
    python3 project1.py 0 BFS graph 300
    *****
"""

import hw1
import copy
import heapq
import sys
import os
import numpy as np
import pandas as pd
import threading
import time
from collections import deque
from timeit import default_timer as timer


class Queue:
    """ A queue using deque """
    def __init__(self):
        self._container = deque()

    def __len__(self):
        return len(self._container)

    def push(self, item):
        self._container.append(item)

    def pop(self):
        return self._container.popleft()


class Stack:
    """ A stack using the deque. """
    def __init__(self):
        self._container = deque()

    def __len__(self):
        return len(self._container)

    def push(self, item):
        self._container.append(item)

    def pop(self):
        return self._container.pop()


class PQueue:
    """ A priority queue (minimum as root) using heapq. """
    def __init__(self, lst):
        self._container = lst
        heapq.heapify(self._container)

    def __len__(self):
        return len(self._container)

    def push(self, item):
        heapq.heappush(self._container, item)

    def pop(self):
        return heapq.heappop(self._container)


class Node:
    """ the nodes that will be generated by our search algorithms
    some algorithms may not use all the information provided """
    def __init__(self, state, parent, path_to_node, cost_to_node, depth, cmp):
        self.state = state                 # The current location
        self.parent = parent               # The state we were previously at
        self.path_to_node = path_to_node   # How we got here
        self.cost_to_node = cost_to_node   # How expensive it was to get here
        self.depth = depth                 # How deep we are
        self.cmp = cmp                     # A comparison function that we use

    def __lt__(self, other):
        """ override the < operator to work for nodes to use the heuristic
        function provided """
        # Don't try to run a function that doesn't exist
        if self.cmp == None:
            return True

        return self.cmp(self) < self.cmp(other)


class RunData:
    """ A simple class to hold and organize all the data from our runs. """
    def __init__(self, solution, total_cost, depth, total_nodes, max_frontier):
        self.solution = solution             # A list of str representing moves
        self.total_cost = total_cost         # Total cost to the end state
        self.depth = depth                   # The depth of the search
        self.total_nodes = total_nodes       # Total nodes created in the run
        self.max_frontier = max_frontier     # The maximum count of nodes stored

    def __str__(self):
        """ The str return for the RunData class. """
        string = "Solution:\n"

        # Add the solution to the string
        if self.solution != None:
            string += ', '.join(self.solution)
        else:
            string += "None"

        # Add some spacing and the total cost
        string += ("\n\nTotal Cost:\n" + str(self.total_cost))

        # Add some spacing and depth of the run
        string += ("\n\nDepth of Solution:\n" + str(self.depth))

        # Add some spacing and the total nodes generated for this run
        string += ("\n\nTotal Nodes Generated:\n" + str(self.total_nodes))

        # Add some spacing and the maximum number of nodes stored in the frontier
        string += ("\n\nMaximum Frontier Length:\n" + str(self.max_frontier))

        return string


class Search:
    """ a superclass for search every algorithm
    just so we don't have to type the same thing in every class """
    def __init__(self, search_type):
        # a python dictionary of all the visited nodes
        self._explored_set = set()

        # True if using tree search
        self._search_type = search_type

        # The directions we can go
        self.dirs = ['U','D','L','R']

        # Initiate the data collection object
        self.run_data = RunData(None, 0, 1, 1, 1)


class BFS(Search):
    """ Implement a Breadth First Search """
    def __init__(self, search_type, environment):
        super(BFS, self).__init__(search_type)

        # The frontier of the search
        self._frontier = Queue()

        # Add the root node to the frontier
        self._frontier.push(Node(environment, None, [], 0, 1, None))

    def run(self):
        """ Run the search algorithm. """

        # loop until we either reach a goal state or run out of states
        while True:
            # If there is no solution, don't return anything
            if len(self._frontier) < 1:
                return self.run_data

            # Get the current node
            current_node = self._frontier.pop()
            # Check if we're using tree search
            if not self._search_type:
                if current_node.state in self._explored_set:
                    continue

            # Include the state in explored set
            self._explored_set.add(current_node.state)

            # Check if the current state is a goal state
            if current_node.state.all_clean():
                # Set the solution, total cost, and max depth
                self.run_data.solution = current_node.path_to_node
                self.run_data.total_cost = current_node.cost_to_node
                self.run_data.depth = current_node.depth

                # Return the run data
                return self.run_data

            # For every direction make a new node
            for dir in self.dirs:
                # Create a deep copy of the environment
                env = copy.deepcopy(current_node.state)

                # Move the agent
                env.move_agent(dir)

                # Add the new state to the frontier
                self._frontier.push(Node(
                    env,
                    current_node,
                    current_node.path_to_node + [dir],
                    current_node.cost_to_node + 1,
                    current_node.depth + 1,
                    current_node.cmp
                ))

                # Update the maximum number of nodes in the frontier
                self.run_data.max_frontier = max(len(self._frontier), self.run_data.max_frontier)

                # Update the total number of nodes generated
                self.run_data.total_nodes += 1


class DFS(Search):
    """ Implement a Depth First Search. """
    def __init__(self, search_type, environment):
        super(DFS, self).__init__(search_type)

        # The frontier of the search
        self._frontier = Stack()

        # Add the root node to the frontier
        self._frontier.push(Node(environment, None, [], 0, 1, None))

    def run(self):
        """ Run the search algorithm. """
        # loop until we either reach a goal state or run out of states
        while True:
            # If there is no solution, don't return anything
            if len(self._frontier) < 1:
                return self.run_data

            # Get the current node
            current_node = self._frontier.pop()
            # Check if we're using tree search
            if not self._search_type:
                if current_node.state in self._explored_set:
                    continue

            # Include the state in explored set
            self._explored_set.add(current_node.state)

            # Check if the current state is a goal state
            if current_node.state.all_clean():
                # Set the solution, total cost, and max depth
                self.run_data.solution = current_node.path_to_node
                self.run_data.total_cost = current_node.cost_to_node
                self.run_data.depth = current_node.depth

                # Return the run data
                return self.run_data

            # For every direction make a new node
            for dir in self.dirs:
                # Create a deep copy of the environment
                env = copy.deepcopy(current_node.state)

                # Move the agent
                env.move_agent(dir)

                # Add the new state to the frontier
                self._frontier.push(Node(
                    env,
                    current_node,
                    current_node.path_to_node + [dir],
                    current_node.cost_to_node + 1,
                    current_node.depth + 1,
                    current_node.cmp
                ))

                # Update the maximum number of nodes in the frontier
                self.run_data.max_frontier = max(len(self._frontier), self.run_data.max_frontier)

                # Update the total number of nodes generated
                self.run_data.total_nodes += 1


class DepthLimitedSearch(Search):
    """ Implement a depth limited search. """
    def __init__(self, search_type, environment, limit):
        super(DepthLimitedSearch, self).__init__(search_type)

        # The frontier of the search
        self._frontier = Stack()

        # The deepest node we are allowed to reach
        self._limit = limit

        # Add the root node to the frontier
        self._frontier.push(Node(environment, None, [], 0, 1, None))

    def run(self):
        """ Run the search algorithm. """
        # loop until we either reach a goal state or run out of states
        while True:
            # If there is no solution, don't return anything
            if len(self._frontier) < 1:
                break
            # Get the current node
            current_node = self._frontier.pop()
            # Check if we're using tree search
            if not self._search_type:
                if current_node.state in self._explored_set:
                    continue

            # if we've hit the limit, don't go any deeper
            if current_node.depth > self._limit:
                continue

            # Include the state in explored set
            self._explored_set.add(current_node.state)

            # Check if the current state is a goal state
            if current_node.state.all_clean():
                # Set the solution, total cost, and max depth
                self.run_data.solution = current_node.path_to_node
                self.run_data.total_cost = current_node.cost_to_node
                self.run_data.depth = current_node.depth

                # Return the run data
                return self.run_data

            # For every direction make a new node
            for dir in self.dirs:
                # Create a deep copy of the environment
                env = copy.deepcopy(current_node.state)

                # Move the agent
                env.move_agent(dir)

                # Add the new state to the frontier
                self._frontier.push(Node(
                    env,
                    current_node,
                    current_node.path_to_node + [dir],
                    current_node.cost_to_node + 1,
                    current_node.depth + 1,
                    current_node.cmp
                ))

                # Update the maximum number of nodes in the frontier
                self.run_data.max_frontier = max(len(self._frontier), self.run_data.max_frontier)

                # Update the total number of nodes generated
                self.run_data.total_nodes += 1

        # We couldn't find a solution
        return self.run_data


class IterativeDeepeningSearch(Search):
    """ Implement an iterative deepening search."""
    def __init__(self, search_type, environment):
        super(IterativeDeepeningSearch, self).__init__(search_type)

        # Save up the environment
        self._env = environment

    def run(self):
        limit = 1

        while True:
            # Create a new Depth-Limited Search
            dls = DepthLimitedSearch(self._search_type, self._env, limit)
            result = dls.run()

            # If we found a solution...
            if result.solution != None:
                # Update the run data with the data from the past runs as well
                result.total_nodes += self.run_data.total_nodes
                result.max_frontier += self.run_data.max_frontier

                return result

            # Update the maximum number of nodes in the frontier
            self.run_data.max_frontier = max(
                result.max_frontier,
                self.run_data.max_frontier)

            # Update the total number of nodes generated
            self.run_data.total_nodes += result.total_nodes

            # Increment the limit
            limit += 1


class GreedyBestFirstSearch(Search):
    """ Implement an gredy best-first search algorithm. """
    def __init__(self, search_type, environment, heuristic):
        super(GreedyBestFirstSearch, self).__init__(search_type)

        # The frontier of the search
        self._frontier = PQueue([])

        # Add the root node to the frontier
        self._frontier.push(Node(environment, None, [], 0, 1, heuristic))

    def run(self):
        """ Run the search algorithm. """
        # loop until we either reach a goal state or run out of states
        while True:
            # If there is no solution, don't return anything
            if len(self._frontier) < 1:
                return self.run_data

            # Get the current node
            current_node = self._frontier.pop()

            # Check if we're using tree search
            if not self._search_type:
                if current_node.state in self._explored_set:
                    continue

            # Include the state in explored set
            self._explored_set.add(current_node.state)


            # Check if the current state is a goal state
            if current_node.state.all_clean():
                # Set the solution, total cost, and max depth
                self.run_data.solution = current_node.path_to_node
                self.run_data.total_cost = current_node.cost_to_node
                self.run_data.depth = current_node.depth

                # Return the run data
                return self.run_data

            # For every direction make a new node
            for dir in self.dirs:
                # Create a deep copy of the environment
                env = copy.deepcopy(current_node.state)

                # Move the agent
                env.move_agent(dir)

                # Add the new state to the frontier
                self._frontier.push(Node(
                    env,
                    current_node,
                    current_node.path_to_node + [dir],
                    current_node.cost_to_node + 1,
                    current_node.depth + 1,
                    current_node.cmp
                ))

                # Update the maximum number of nodes in the frontier
                self.run_data.max_frontier = max(len(self._frontier), self.run_data.max_frontier)

                # Update the total number of nodes generated
                self.run_data.total_nodes += 1


class AStarSearch(Search):
    """ Implement an A* search algorithm. """
    def __init__(self, search_type, environment, heuristic):
        super(AStarSearch, self).__init__(search_type)

        # The frontier of the search
        self._frontier = PQueue([])

        # Also factor in the cost evaluation with a lambds function
        a_star_h_func = lambda node : heuristic(node) + node.cost_to_node

        # Add the root node to the frontier
        self._frontier.push(Node(environment, None, [], 0, 1, heuristic))

    def run(self):
        """ Run the search algorithm. """
        # loop until we either reach a goal state or run out of states
        while True:
            # If there is no solution, don't return anything
            if len(self._frontier) < 1:
                return self.run_data

            # Get the current node
            current_node = self._frontier.pop()

            # Check if we're using tree search
            if not self._search_type:
                if current_node.state in self._explored_set:
                    continue

            # Include the state in explored set
            self._explored_set.add(current_node.state)


            # Check if the current state is a goal state
            if current_node.state.all_clean():
                # Set the solution, total cost, and max depth
                self.run_data.solution = current_node.path_to_node
                self.run_data.total_cost = current_node.cost_to_node
                self.run_data.depth = current_node.depth

                # Return the run data
                return self.run_data

            # For every direction make a new node
            for dir in self.dirs:
                # Create a deep copy of the environment
                env = copy.deepcopy(current_node.state)

                # Move the agent
                env.move_agent(dir)

                # Add the new state to the frontier
                self._frontier.push(Node(
                    env,
                    current_node,
                    current_node.path_to_node + [dir],
                    current_node.cost_to_node + 1,
                    current_node.depth + 1,
                    current_node.cmp
                ))

                # Update the maximum number of nodes in the frontier
                self.run_data.max_frontier = max(len(self._frontier), self.run_data.max_frontier)

                # Update the total number of nodes generated
                self.run_data.total_nodes += 1


def check_adjacent(current_node):
    """ In the given state, return the number of dirty square adjacent to the
        agent. """
    adjacent = current_node.state.return_adjacent()
    return - adjacent.count("Dirt") # cuz min heap


def check_dirt(current_node):
    """ Return the number of dirty square in the environment. """

    return current_node.state.count_dirt()


def run_with_timer(search_obj):
    """ A timer for the search algorithms. """

    start = timer()
    results = search_obj.run()
    end = timer()
    # Check if there's a solution
    if results.solution != None:
        # Adds the time used to the results collected
        print(results, "\n\nRun Time:\n" + str(end - start))

    os._exit(0)


def get_cmd_args():
    """ Parse the command line and return arguments """
    # Map the search algorithms to a dictionary and use the argument as the key.
    algs = {
        "BFS": BFS,
        "DFS": DFS,
        "DLS": DepthLimitedSearch,
        "IDS": IterativeDeepeningSearch,
        "GBFS": GreedyBestFirstSearch,
        "A*": AStarSearch}

    # Command-line arguments implementations
    # Check number of arguments
    if len(sys.argv) < 4 or len(sys.argv) > 5:
        print("Incorrect call to program; please refer to docstring")
        return

    # Check for lack of optional argument
    max_time = -1 # placeholder value for lack of argument
    if len(sys.argv) < 5:
        max_time = 300 # if no time is provided, run for 5 mins max

    # Try to get arguments from the command line
    try:
        # Make the environment
        env = hw1.make_vacuum_environment(int(sys.argv[1]))

        # Get the search algorithm
        search_alg = algs[sys.argv[2].upper()]

        # Convert the search type to a boolean that we use in our class
        search_type = True
        if sys.argv[3].upper() != "TREE":
            search_type = False

        if max_time < 0:
            max_time = int(sys.argv[4])
    except:
        print("Error in arguments; please refer to docstring")
        os._exit(0)

    return (env, search_alg, search_type, max_time)


def run_search():
    # Get the arguments from the command line
    (env, search_alg, search_type, max_time) = get_cmd_args()

    if search_alg == GreedyBestFirstSearch:
        obj = search_alg(search_type, env, check_dirt)
    elif search_alg == AStarSearch:
        obj = search_alg(search_type, env, check_dirt)
    elif search_alg == DepthLimitedSearch:
        obj = search_alg(search_type, env, 9)
    else:
        obj = search_alg(search_type, env)

    # Begin a new processing thread for the search
    search_run = threading.Thread(target=run_with_timer, args=(obj,))
    search_run.start()

    # Wait for the specified number of seconds
    time.sleep(max_time)

    if search_run.is_alive():
        print("The search took too long and was automatically stopped")

    os._exit(0)


def main():
    """ The main function that runs the driver codes for search algorithm
        implementations and testing funcitons. """

    # Run the algorithm as normal
    run_search()


if __name__ == "__main__":
    main()
